# scripts/load_reviews_to_oracle.py

import oracledb
import pandas as pd
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- Oracle Connection Details --- 
# IMPORTANT: Replace with your actual Oracle credentials and DSN
ORACLE_USER = os.environ.get('ORACLE_USER', 'your_username')
ORACLE_PASSWORD = os.environ.get('ORACLE_PASSWORD', 'your_password')
# Example DSN for Oracle XE: 'localhost:1521/XEPDB1' or 'localhost:1521/XE'
ORACLE_DSN = os.environ.get('ORACLE_DSN', 'your_dsn')

# Path to the CSV file
CSV_FILE_PATH = os.path.join(os.path.dirname(__file__), '..', 'data', 'google_play_reviews.csv')

def get_db_connection():
    """Establishes a connection to the Oracle database."""
    try:
        connection = oracledb.connect(
            user=ORACLE_USER,
            password=ORACLE_PASSWORD,
            dsn=ORACLE_DSN
        )
        print("Successfully connected to Oracle Database!")
        return connection
    except oracledb.Error as e:
        print(f"Error connecting to Oracle: {e}")
        return None

def create_tables(connection):
    """Creates the Banks and Reviews tables if they don't exist."""
    cursor = connection.cursor()
    try:
        # Create Banks Table
        cursor.execute("""
            CREATE TABLE Banks (
                bank_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                bank_name VARCHAR2(255) NOT NULL UNIQUE,
                app_id VARCHAR2(255) UNIQUE
            )
        """)
        print("Table 'Banks' created successfully or already exists.")
    except oracledb.DatabaseError as e:
        error_obj, = e.args
        if error_obj.code == 955: # ORA-00955: name is already used by an existing object
            print("Table 'Banks' already exists.")
        else:
            print(f"Error creating 'Banks' table: {e}")
            raise

    try:
        # Create Reviews Table
        cursor.execute("""
            CREATE TABLE Reviews (
                review_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                bank_id NUMBER NOT NULL,
                review_text CLOB NOT NULL,
                rating NUMBER(1) NOT NULL,
                review_date DATE NOT NULL,
                source VARCHAR2(100),
                CONSTRAINT fk_bank FOREIGN KEY (bank_id) REFERENCES Banks(bank_id)
            )
        """)
        print("Table 'Reviews' created successfully or already exists.")
    except oracledb.DatabaseError as e:
        error_obj, = e.args
        if error_obj.code == 955:
            print("Table 'Reviews' already exists.")
        else:
            print(f"Error creating 'Reviews' table: {e}")
            raise
    finally:
        cursor.close()

def load_data_to_oracle(connection):
    """Loads data from CSV into Oracle tables."""
    if not os.path.exists(CSV_FILE_PATH):
        print(f"Error: CSV file not found at {CSV_FILE_PATH}")
        return

    df = pd.read_csv(CSV_FILE_PATH)
    # Ensure date format is consistent for Oracle
    df['date'] = pd.to_datetime(df['date']).dt.strftime('%Y-%m-%d')

    cursor = connection.cursor()
    bank_id_map = {}

    try:
        # 1. Populate Banks table and get bank_ids
        unique_banks = df['bank'].unique()
        for bank_name in unique_banks:
            if pd.isna(bank_name):
                print(f"Skipping bank with null name.")
                continue
            try:
                # Check if bank already exists
                cursor.execute("SELECT bank_id FROM Banks WHERE bank_name = :1", [bank_name])
                result = cursor.fetchone()
                if result:
                    bank_id = result[0]
                else:
                    # Insert bank and get the new bank_id (Oracle handles identity generation)
                    # We need to fetch the generated ID if not using RETURNING INTO with older cx_Oracle
                    # With oracledb and GENERATED AS IDENTITY, we can insert directly.
                    # For simplicity, we'll re-query, or assume it's there after insert.
                    cursor.execute("INSERT INTO Banks (bank_name) VALUES (:1)", [bank_name])
                    # Re-fetch to get the ID
                    cursor.execute("SELECT bank_id FROM Banks WHERE bank_name = :1", [bank_name])
                    bank_id_result = cursor.fetchone()
                    if bank_id_result:
                        bank_id = bank_id_result[0]
                    else:
                        print(f"Error: Could not retrieve bank_id for {bank_name} after insert.")
                        continue # or raise error
                bank_id_map[bank_name] = bank_id
                print(f"Processed bank: {bank_name} with ID: {bank_id}")
            except oracledb.Error as e:
                print(f"Error processing bank {bank_name}: {e}")
                # Decide if to continue or stop

        # 2. Populate Reviews table
        reviews_to_insert = []
        for index, row in df.iterrows():
            bank_name = row['bank']
            if pd.isna(bank_name) or bank_name not in bank_id_map:
                print(f"Skipping review due to missing or unprocessed bank: {bank_name}")
                continue
            
            bank_id = bank_id_map[bank_name]
            review_text = str(row['review']) # Ensure CLOB compatibility
            rating = int(row['rating'])
            review_date_str = row['date'] # Already formatted as YYYY-MM-DD
            source_val = row['source']

            reviews_to_insert.append((
                bank_id,
                review_text,
                rating,
                oracledb.DateFromTicks(pd.Timestamp(review_date_str).timestamp()), # Convert string to Oracle DATE
                source_val
            ))
        
        if reviews_to_insert:
            cursor.executemany("""
                INSERT INTO Reviews (bank_id, review_text, rating, review_date, source)
                VALUES (:1, :2, :3, :4, :5)
            """, reviews_to_insert)
            print(f"Successfully inserted {len(reviews_to_insert)} reviews.")
        else:
            print("No reviews to insert.")

        connection.commit()
        print("Data committed to database.")

    except pd.errors.EmptyDataError:
        print(f"Error: The CSV file {CSV_FILE_PATH} is empty or not valid.")
    except KeyError as e:
        print(f"Error: Missing expected column in CSV: {e}") 
    except oracledb.Error as e:
        print(f"Error during data loading: {e}")
        connection.rollback()
    finally:
        cursor.close()

def main():
    print("Starting Oracle DB setup and data loading process...")
    
    # IMPORTANT: Ensure ORACLE_USER, ORACLE_PASSWORD, and ORACLE_DSN are set correctly
    # either in your environment variables or directly in the script (less secure).
    print(f"Attempting to connect with User: {ORACLE_USER}, DSN: {ORACLE_DSN}")
    
    connection = get_db_connection()
    if connection:
        try:
            create_tables(connection)
            load_data_to_oracle(connection)
        finally:
            connection.close()
            print("Oracle connection closed.")
    else:
        print("Failed to connect to Oracle. Please check your credentials and DSN.")

if __name__ == "__main__":
    main()
